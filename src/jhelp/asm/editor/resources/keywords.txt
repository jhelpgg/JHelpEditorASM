*****************************
*** Declaration key words ***
*****************************

class|Declare class|<html>Declare the class in ASM files:<br><table border=1><tr><td>class &lt;ClassCompleteName&gt;</td></tr></table></html>
}|Close code|Close the code for a method (End method declaration)
extends|Parent class|<html>Specifies the parent class:<br><table border=1><tr><td>extends &lt;ClassName&gt;</td></tr></table></html>
field|Field declaration|<html>Declare a field:<br><table border=1><tr><td>field &lt;type&gt; &lt;name&gt;</td></tr></table></html>
field_reference|Reference to external field|<html>Declare a reference to external field<br>Filed not on this class<br><table border=1><tr><td>field_reference &lt;className&gt; &lt;type&gt; &lt;name&gt; &lt;alias&gt;</td></tr></table><ul><li><b>className</b> Name of the class where find the field</li><li><b>type</b> Type of the field</li><li><b>name</b> Name of the field in the class</li><li><b>alias</b> Alias to use to reference this field in <i>GETFIELD</i>, <i>GETSTATIC</i>, <i>PUTFIELD</i> or <i>PUTSTATIC</i></li></ul></html>
implements|Interface implementation|<html>Add interface to implements:<br><table border=1><tr><td>implements &lt;ClassName&gt;</td></tr></table></html>
import|Import class|<html>Add an import:<br><table border=1><tr><td>import &lt;ClassCompleteName&gt;</td></tr></table></html>
method|Method declaration|<html>Start method declaration:<br><table border=1><tr><td>method &lt;name&gt;</td></tr></table></html>
{|Open code|Start the method code
parameter|Add parameter|<html>Add method parameter:<br><table border=1><tr><td>parameter &lt;type&gt; &lt;name&gt;</td></tr></table></html>
return|Return type|<html>Declare method return type:<br><table border=1><tr><td>return &lt;type&gt;</td></tr></table></html>
throws|Throw declaration|<html>Add exception throws by method:<br><table border=1><tr><td>throws &lt;ClassName&gt;</td></tr></table></html>********************

*********************
*** Operand codes *** 
*********************

AALOAD|Load from array|<html>Description : Load object reference from array<br>Syntax :<br><table border=1><tr><td>AALOAD</td></tr></table>Operand stack :<table border=1><tr><td>..., array_reference, index => ..., value</td></tr></table><br>Where :<ul><li>arrayref : Reference of array elements type</li><li>index : Array index (int)</li><li>value : Reference of the desired object inside the array</li></ul></html> 
AASTORE|Store into array|<html>Description : Store object reference into array<br>Syntax :<br><table border=1><tr><td>AASTORE</td></tr></table>Operand stack :<table border=1><tr><td>..., array_reference, index, value => ...</td></tr></table><br>Where :<ul><li>arrayref : Reference of array elements type</li><li>index : Array index (int)</li><li>value : Reference object to put inside the array at desired index</li></ul></html>
ACONST_NULL|Push null|<html>Description : Push null<br>Syntax :<br><table border=1><tr><td>ACONST_NULL</td></tr></table><br>Operand stack : <table border=1><tr><td>... => ..., null</td></tr></table></html>
ALOAD|Load local variable|<html>Description : Load reference from local variable<br>Syntax :<br><table border=1><tr><td>ALOAD &ltname&gt;</td></tr></table><br>Where :<ul><li>name : Current method variable name OR current method parameter name OR 'this'</li></ul><br>Operand stack : <table border=1><tr><td>... => ..., objectref</td></tr></table><br>Where :<ul><li>objectref : Reference object loaded</li></ul><br>Details: If <i>name</i> is a method variable name, the corresponding variable must have previously initialized (Even with null)</html>
ANEWARRAY|Create array|<html>Description : Create new array of reference<br>Syntax :<br><table border=1><tr><td>ANEWARRAY &lt;Type&gt;</td></tr></table><br>Where :<ul><li>Type : is the variable type.</li></ul><br>Operand stack : <table border=1><tr><td>..., count => ..., arrayref</td></tr></table><br>Where :<ul><li>count : Array size (int)</li><li>arrayref : Reference on created array</li></ul></html>
ARETURN|Return reference|<html>Description : Return reference from method <br> Syntax :<br> <table border=1><tr><td>ARETURN</td></tr></table><br> Operand stack : <table border=1><tr><td>..., objectref => [empty]</td></tr></table><br> Where : <ul> <li>objectref : reference of object to return</li> </ul> <br> Details:If the current method is a synchronized method, the monitor entered or reentered on invocation of the method is updated and possibly exited as if by execution of a monitorexit instruction in the current thread. If no exception is thrown, <b>objectref</b> is popped from the operand stack of the current frame and pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.</html>
ARRAYLENGTH|Array length|<html>Description : Get length of array<br> Syntax :<br> <table border=1><tr><td>ARRAYLENGTH</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref => ..., length</td></tr></table><br> Where : <ul> <li>arrayref : Reference on aarray</li> <li>length : Array length (int)</li> </ul></html>
ASTORE|Store in local variable|<html>Description : Store reference into local variable<br> Syntax :<br> <table border=1><tr><td>ASTORE &lt;name&gt;</td></tr></table><br> Where : <ul> <li>name : Current method variable name OR current method parameter name</li> </ul> <br> Operand stack : <table border=1><tr><td>..., objectref => ...</td></tr></table><br> Where : <ul> <li>objectref : Object reference to push on local variable</li> </ul></html>
ATHROW|Throw exception|<html>Description : Throw exception or error<br> Syntax :<br> <table border=1><tr><td>ATHROW</td></tr></table><br> Operand stack : <table border=1><tr><td>.., objectref => objectref</td></tr></table><br> Where : <ul> <li>objectref : Reference on exception to throw</li> </ul></html>
BALOAD|Load byte/boolean from array|<html>Description : Load byte or boolean from array<br> Syntax :<br> <table border=1><tr><td>BALOAD</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref, index => ..., value</td></tr></table><br> Where : <ul> <li>arrayref : reference on array</li> <li>index : Array index (int)</li> <li>value : Value in array at given index (int)</li> </ul> <br> Details: The byte value in the component of the array at <b>index</b> is retrieved, sign-extended to an int value, and pushed onto the top of the operand stack.</html>
BASTORE|Store byte/boolean to array|<html>Description : Store into byte or boolean array<br> Syntax :<br> <table border=1><tr><td>BASTORE</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref, index, value => ...</td></tr></table><br> Where : <ul> <li>arrayref : reference on array</li> <li>index : Array index (int)</li> <li>value : Value to store in array at given index (int)</li> </ul> <br> Details:The int <b>value</b> is truncated to a byte and stored as the component of the array indexed by <b>index</b>.</html>
BIPUSH|Push byte|<html>Description : Push byte<br> Syntax :<br> <table border=1><tr><td>BIPUSH &lt;value&gt;</td></tr></table><br> Where : <ul> <li>value : Constant value to push</li> </ul> <br> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>value: pushed value (int)</li> </ul> <br> Details: The immediate <b>value</b> is sign-extended to an int <b>value</b>. That <b>value</b> is pushed onto the operand stack.</html>
BREAKPOINT|Break point|<html>Description : Make a break point. Here does nothing<br> Syntax :<br> <table border=1><tr><td>BREAKPOINT</td></tr></table></html>
CALOAD|Load char from array|<html>Description : Load char from array<br> Syntax :<br> <table border=1><tr><td>CALOAD</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref, index => ..., value</td></tr></table><br> Where : <ul> <li>arrayref : reference on array</li> <li>index : Array index (int)</li> <li>value : Value in array at given index (int)</li> </ul> <br> Details: The component of the array at index is retrieved and zero-extended to an int value. That value is pushed onto the operand stack.</html>
CASTORE|Store char to array|<html>Description : Store into char array<br> Syntax :<br> <table border=1><tr><td>CASTORE</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref, index, value => ...</td></tr></table><br> Where : <ul> <li>arrayref : reference on array</li> <li>index : Array index (int)</li> <li>value : Value to put in array at given index (int)</li> </ul> <br> Details: The int value is truncated to a char and stored as the component of the array indexed by index.</html>
CHECKCAST|Cast object|<html>Description : Cast object to given type<br> Syntax :<br> <table border=1><tr><td>CHECKCAST &lt;ClassName&gt;</td></tr></table><br> Where : <ul> <li>ClassName : The complete class name (with the package) or the short version (Must be in imports, "java.lang" or same package of the class)</li> </ul> <br> Operand stack : <table border=1><tr><td>..., objectref1 => ..., objectref2</td></tr></table><br> Where : <ul> <li>objectref1 : reference to the object to cast</li><li>objectref2 : casted reference</li> </ul> <br> Details: The cast must be possible else a ClassCastException happen</html>
D2F|double TO float|<html>Description : Convert double to float<br> Syntax :<br> <table border=1><tr><td>D2F</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : double to convert</li> <li>result : float converted</li> </ul> <br> Details: The value is converted to a float result using IEEE 754 round to nearest mode</html>
D2I|double TO int|<html>Description : Convert double to int<br> Syntax :<br> <table border=1><tr><td>D2I</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : double to convert</li> <li>result : int converted</li> </ul> <br> Details: <ul> <li>If the value' is NaN, the result of the conversion is an int 0</li> <li>Otherwise, if the value is not an infinity, it is rounded to an integer value V, rounding towards zero using IEEE 754 round towards zero mode. If this integer value V can be represented as an int, then the result is the int value V.</li> <li>Otherwise, either the value must be too small (a negative value of large magnitude or negative infinity), and the result is the smallest representable value of type int, or the value must be too large (a positive value of large magnitude or positive infinity), and the result is the largest representable value of type int.</li> </ul></html>
D2L|double TO long|<html>Description : Convert double to long<br> Syntax :<br> <table border=1><tr><td>D2L</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : double to convert</li> <li>result : long converted</li> </ul> <br> Details: <ul> <li>If the value' is NaN, the result of the conversion is a long 0.</li> <li>Otherwise, if the value' is not an infinity, it is rounded to an integer value V, rounding towards zero using IEEE 754 round towards zero mode. If this integer value V can be represented as a long, then the result is the long value V.</li> <li>Otherwise, either the value' must be too small (a negative value of large magnitude or negative infinity), and the result is the smallest representable value of type long, or the value' must be too large (a positive value of large magnitude or positive infinity), and the result is the largest representable value of type long.</li> </ul></html>
DADD|Addition of double|<html> Description : Add double<br> Syntax :<br> <table border=1><tr><td>DADD</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first double</li> <li>value2 : second double</li> <li>result : addition result (double)</li> </ul></html>
DALOAD|Load double from array|<html> Description : Load double from array<br> Syntax :<br> <table border=1><tr><td>DALOAD</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref, index => ..., value</td></tr></table><br> Where : <ul> <li>arrayref : reference on array</li> <li>index : Array index (int)</li> <li>value : Value in array at given index (double)</li> </ul></html>
DASTORE|Store double to array|<html> Description : Store into double array<br> Syntax :<br> <table border=1><tr><td>DASTORE</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref, index, value => ...</td></tr></table><br> Where : <ul> <li>arrayref : reference on array</li> <li>index : Array index (int)</li> <li>value : Value to put in array at given index (double)</li> </ul></html>
DCMPG|Compare double|<html> Description : Compare double (Great if NaN)<br> Syntax :<br> <table border=1><tr><td>DCMPG</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first double</li> <li>value2 : second double</li> <li>result : comparison result (int)</li> </ul> <br> Details: <ul> <li>If value1' is greater than value2', the int value 1 is pushed onto the operand stack.</li> <li>Otherwise, if value1' is equal to value2', the int value 0 is pushed onto the operand stack.</li> <li>Otherwise, if value1' is less than value2', the int value -1 is pushed onto the operand stack.</li> <li>Otherwise, at least one of value1' or value2' is NaN pushes the int value 1 onto the operand stack</li> </ul></html>
DCMPL|Compare double|<html> Description : Compare double (Low if NaN)<br> Syntax :<br> <table border=1><tr><td>DCMPG</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first double</li> <li>value2 : second double</li> <li>result : comparison result (int)</li> </ul> <br> Details: <ul> <li>If value1' is greater than value2', the int value 1 is pushed onto the operand stack.</li> <li>Otherwise, if value1' is equal to value2', the int value 0 is pushed onto the operand stack.</li> <li>Otherwise, if value1' is less than value2', the int value -1 is pushed onto the operand stack.</li> <li>Otherwise, at least one of value1' or value2' is NaN pushes the int value -1 onto the operand stack</li> </ul></html>
DCONST|Push 0 or 1|<html> Description : Push double 0 or 1<br> Syntax :<br> <table border=1><tr><td>DCONST &lt;value&gt;</td></tr></table><br> Where : <ul> <li>value : Must be 0 or 1</li> </ul> <br> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>value : the value pushed (0 or 1) (double)</li> </ul></html>
DDIV|Division of double|<html> Description : Divide double<br> Syntax :<br> <table border=1><tr><td>DADD</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first double</li> <li>value2 : second double</li> <li>result : division result (double)</li> </ul></html>
DLOAD|Load local variable|<html> Description : Load double from local variable<br> Syntax :<br> <table border=1><tr><td>DLOAD &lt;name&gt;</td></tr></table><br> Where : <ul> <li>name : Current method variable name OR current method parameter name</li> </ul> <br> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>value : value of the method variable or parameter</li> </ul> <br> Details: If <table border=1><tr><td>name</td></tr></table> is a method variable name, the corresponding variable must have previously initialized (Even with 0)</html>
DMUL|Multiplication of double|<html> Description : Multiply double<br> Syntax :<br> <table border=1><tr><td>DMUL</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first double</li> <li>value2 : second double</li> <li>result : multiplication result (double)</li> </ul></html>
DNEG|Negate double|<html> Description : Negate double<br> Syntax :<br> <table border=1><tr><td>DNEG</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : Value to negate (double)</li> <li>result : Negated result (double)</li> </ul></html>
DREM|Remainder of double|<html> Description : Remainder on double<br> Syntax :<br> <table border=1><tr><td>DREM</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first double</li> <li>value2 : second double</li> <li>result : remainder result (double)</li> </ul></html>
DRETURN|Return double|<html> Description : Return double from method<br> Syntax :<br> <table border=1><tr><td>DRETURN</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => [empty]</td></tr></table><br> Where : <ul> <li>value : value to return (double)</li> </ul></html>
DSTORE|Store in local variable|<html> Description : Store double to local variable<br> Syntax :<br> <table border=1><tr><td>DSTORE &lt;name&gt;</td></tr></table><br> Where : <ul> <li>name : Current method variable name OR current method parameter name</li> </ul> Operand stack : <table border=1><tr><td>...,value => ...</td></tr></table><br> Where : <ul> <li>value : value to store in the method variable or parameter</li> </ul></html>
DSUB|Subtraction of double|<html> Description : Subtract double<br> Syntax :<br> <table border=1><tr><td>DSUB</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first double</li> <li>value2 : second double</li> <li>result : subtraction result (double)</li> </ul></html>
DUP|Duplicate stack|<html> Description : Duplicate the top operand stack value<br> Syntax :<br> <table border=1><tr><td>DUP</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., value, value</td></tr></table><br> Where : <ul> <li>value : value to duplicate</li> </ul> <br> Details: Value can't be a double or long</html>
DUP_X1|Duplicate stack|<html> Description : Duplicate the top operand stack value and insert two values down<br> Syntax :<br> <table border=1><tr><td>DUP_X1</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value2, value1 => ..., value1, value2, value1</td></tr></table><br> Where : <ul> <li>value1 : value to duplicate</li> <li>value2 : value to just move</li> </ul> <br> Details: value1 and value2 can't be double or long</html>
DUP_X2|Duplicate stack|<html> Description : Duplicate the top operand stack value and insert two or three values down<br> Syntax :<br> <table border=1><tr><td>DUP_X2</td></tr></table><br> Operand stack : <table border=1><tr><td>.., value3, value2, value1 => ..., value1, value3, value2, value1</td></tr></table><br> Where : <ul> <li>value1 : value to duplicate</li> <li>value2 : value to just move</li> <li>value3 : value to just move</li> </ul> <br> Details: value1, value2 and value3 can't be double or long <br> <br> <h1><b>OR</b></h1> <br> Operand stack : <table border=1><tr><td>.., value2, value1 => ..., value1, value2, value1</td></tr></table><br> Where : <ul> <li>value1 : value to duplicate</li> <li>value2 : value to just move</li> </ul> <br> Details: value1 not a long nor double, value2 double or long</html>
DUP2|Duplicate stack|<html> Description : Duplicate the top one or two operand stack values<br> Syntax :<br> <table border=1><tr><td>DUP2</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value2, value1 => ..., value2, value1, value2, value1</td></tr></table><br> Where : <ul> <li>value1 : value to duplicate</li> <li>value2 : value to duplicate</li> </ul> <br> Details:value1 and value2 can't be double or long<br> <br> <h1><b>OR</b></h1> <br> Operand stack : <table border=1><tr><td>..., value => ...,value, value</td></tr></table><br> Where <ul> <li>value : value to duplicate</li> * </ul> <br> Details:value double or long</html>
DUP2_X1|Duplicate stack|<html> Description : Duplicate the top one or two operand stack values and insert two or three values down<br> Syntax :<br> <table border=1><tr><td>DUP2_X1</td></tr></table><br> Operand stack : <table border=1><tr><td>.., value3, value2, value1 => ..., value2, value1, value3, value2, value1</td></tr></table><br> Where : <ul> <li>value1 : value to duplicate</li> <li>value2 : value to duplicate</li> <li>value3 : value to just move</li> </ul> Details: value1, value2 and value3 not long nor double<br> <br> <h1><b>OR</b></h1> <br> Operand stack : <table border=1><tr><td>..., value2, value1 => ..., value1, value2, value1</td></tr></table><br> Where <ul> <li>value1 : value to duplicate</li> <li>value2 : value to just move</li> </ul> Details: value1 long or double and value2 not long nor double</html>
DUP2_X2|Duplicate stack|<html> Description : Duplicate the top one or two operand stack values and insert two, three, or four values down<br> Syntax :<br> <table border=1><tr><td>DUP2_X2</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value4, value3, value2, value1 => ..., value2, value1, value4, value3, value2, value1</td></tr></table><br> Where : <ul> <li>value1 : not long nor double</li> <li>value2 : not long nor double</li> <li>value3 : not long nor double</li> <li>value4 : not long nor double</li> </ul> <br> <h1><b>OR</b></h1> <br> Operand stack : <table border=1><tr><td>..., value3, value2, value1 => ..., value1, value3, value2, value1</td></tr></table> <br> Where : <ul> <li>value1 : long or double</li> <li>value2 : not long nor double</li> <li>value3 : not long nor double</li> </ul> <br> <h1><b>OR</b></h1> <br> Operand stack : <table border=1><tr><td>..., value3, value2, value1 => ..., value2, value1, value3, value2, value1</td></tr></table> <br> Where : <ul> <li>value1 : not long nor double</li> <li>value2 : not long nor double</li> <li>value3 : long or double</li> </ul> <br> <h1><b>OR</b></h1> <br> Operand stack : <table border=1><tr><td>..., value2, value1 => ..., value1, value2, value1</td></tr></table> <br> Where : <ul> <li>value1 : long or double</li> <li>value2 : long or double</li> </ul></html>
F2D|float to double|<html> Description : Convert float to double<br> Syntax :<br> <table border=1><tr><td>F2D</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : Value to convert (float)</li> <li>result : Converted value (double)</li> </ul></html>
F2I|float to int|<html> Description : Convert float to int<br> Syntax :<br> <table border=1><tr><td>F2I</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : Value to convert (float)</li> <li>result : Converted value (int)</li> </ul> Details: <ul> <li>If the value' is NaN, the result of the conversion is an int 0</li> <li>Otherwise, if the value' is not an infinity, it is rounded to an integer value V, rounding towards zero using IEEE 754 round towards zero mode. If this integer value V can be represented as an int, then the result is the int value V.</li> <li>Otherwise, either the value' must be too small (a negative value of large magnitude or negative infinity), and the result is the smallest representable value of type int, or the value' must be too large (a positive value of large magnitude or positive infinity), and the result is the largest representable value of type int.</li> </ul></html>
F2L|float to long|<html> Description : Convert float to long<br> Syntax :<br> <table border=1><tr><td>F2L</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : Value to convert (float)</li> <li>result : Converted value (long)</li> </ul> Details: <ul> <li>If the value' is NaN, the result of the conversion is a long 0.</li> <li>Otherwise, if the value' is not an infinity, it is rounded to an integer value V, rounding towards zero using IEEE 754 round towards zero mode. If this integer value V can be represented as a long, then the result is the long value V.</li> <li>Otherwise, either the value' must be too small (a negative value of large magnitude or negative infinity), and the result is the smallest representable value of type long, or the value' must be too large (a positive value of large magnitude or positive infinity), and the result is the largest representable value of type long.</li> </ul></html>
FADD|Addition of float|<html> Description : Add float<br> Syntax :<br> <table border=1><tr><td>FADD</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first float</li> <li>value2 : second float</li> <li>result : addition result (float)</li> </ul></html>
FALOAD|Load float from array|<html> Description : Load float from array<br> Syntax :<br> <table border=1><tr><td>FALOAD</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref, index => ..., value</td></tr></table><br> Where : <ul> <li>arrayref: Reference to array</li> <li>index : Array index (int)</li> <li>value : Value in array at given index (float)</li> </ul></html>
FASTORE|Store float in array|<html> Description :Store into float array<br> Syntax :<br> <table border=1><tr><td>FASTORE</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref, index, value => ...</td></tr></table><br> Where : <ul> <li>arrayref: Reference to array</li> <li>index : Array index (int)</li> <li>value : Value to put in array at given index (float)</li> </ul></html>
FCMPG|Compare float|<html> Description : Compare float (Great NaN)<br> Syntax :<br> <table border=1><tr><td>FCMPG</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., resul</td></tr></table>t<br> Where : <ul> <li>value1 : first float</li> <li>value2 : second float</li> <li>result : comparison result (int)</li> </ul> Details: <ul> <li>If value1' is greater than value2', the int value 1 is pushed onto the operand stack.</li> <li>Otherwise, if value1' is equal to value2', the int value 0 is pushed onto the operand stack.</li> <li>Otherwise, if value1' is less than value2', the int value -1 is pushed onto the operand stack.</li> <li>Otherwise, at least one of value1' or value2' is NaN. The instruction pushes the int value 1 onto the operand stack </li> </ul></html>
FCMPL|Compare float|<html> Description : Compare float (Low NaN)<br> Syntax :<br> <table border=1><tr><td>FCMPL</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first float</li> <li>value2 : second float</li> <li>result : comparison result (int)</li> </ul> Details: <ul> <li>If value1' is greater than value2', the int value 1 is pushed onto the operand stack.</li> <li>Otherwise, if value1' is equal to value2', the int value 0 is pushed onto the operand stack.</li> <li>Otherwise, if value1' is less than value2', the int value -1 is pushed onto the operand stack.</li> <li>Otherwise, at least one of value1' or value2' is NaN. The instruction pushes the int value -1 onto the operand stack </li> </ul></html>
FCONST|Push 0, 1 or 2|<html> Description : Push float constant 0,1 or 2<br> Syntax :<br> <table border=1><tr><td>FCONST &lt;value&gt;</td></tr></table><br> Where : <ul> <li>value : value to push 0, 1 or 2</li> </ul> <br> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>value : value pushed 0, 1 or 2 (float)</li> </ul></html>
FDIV|Division of float|<html> Description : Divide float<br> Syntax :<br> <table border=1><tr><td>FDIV</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first float</li> <li>value2 : second float</li> <li>result : division result (float)</li> </ul></html>
FLOAD|Load local variable|<html> Description : Load float from local variable<br> Syntax :<br> <table border=1><tr><td>FLOAD &lt;name&gt;</td></tr></table><br> Where : <ul> <li>name : Current method variable name OR current method parameter name</li> </ul> <br> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>value : value of the method variable or parameter</li> </ul> <br> Details: If <table border=1><tr><td>name</td></tr></table> is a method variable name, the corresponding variable must have previously initialized (Even with 0)</html>
FMUL|Multiplication of float|<html> Description : Multiply float<br> Syntax :<br> <table border=1><tr><td>FMUL</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first float</li> <li>value2 : second float</li> <li>result : multiplication result (float)</li> </ul></html>
FNEG|Negate float|<html> Description : Negate float<br> Syntax :<br> <table border=1><tr><td>FNEG</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : float to negate</li> <li>result : negated float</li> </ul></html>
FREM|Remainder of float|<html> Description : Remainder float<br> Syntax :<br> <table border=1><tr><td>FREM</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first float</li> <li>value2 : second float</li> <li>result : remainder result (float)</li> </ul></html>
FRETURN|Return float|<html> Description : Return float from method<br> Syntax :<br> <table border=1><tr><td>FRETURN</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => [empty]</td></tr></table><br> Where : <ul> <li>value : vlaue to return (float)</li> </ul></html>
FSTORE|Store in local variable|<html> Description : Store float to local variable<br> Syntax :<br> <table border=1><tr><td>FSTORE &lt;name&gt;</td></tr></table><br> Where : <ul> <li>name : Current method variable name OR current method parameter name</li> </ul> Operand stack : <table border=1><tr><td>...,value => ...</td></tr></table><br> Where : <ul> <li>value : value to store in the method variable or parameter</li> </ul></html>
FSUB|Subtract float|<html> Description : Subtract float<br> Syntax :<br> <table border=1><tr><td>FMUL</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first float</li> <li>value2 : second float</li> <li>result : subtraction result (float)</li> </ul></html>
GETFIELD|Obtain field|<html> Description : Fetch field from object<br> Syntax :<br> <table border=1><tr><td>GETFIELD &lt;fieldName&gt;</td></tr></table><br> Where : <ul> <li>fieldName : Name/alias of the field to get the value</li> </ul> <br> Operand stack : <table border=1><tr><td>..., objectref => ..., value</td></tr></table><br> Where : <ul> <li>objectref : reference to the object.</li> <li>value : field value</li> </ul></html>
GETSTATIC|Obtain field|<html> Description : Get static field from class<br> Syntax :<br> <table border=1><tr><td>GETSTATIC  &lt;fieldName&gt;</td></tr></table><br> Where : <ul> <li>fieldName : Name/alias of the field to get the value</li> </ul> <br> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>value : field value</li> </ul></html>
GOTO|Go to label|<html> Description : Branch always<br> Syntax :<br> <table border=1><tr><td>GOTO &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go</li> </ul> Operand stack : <table border=1><tr><td>No change</td></tr></table><br> Details: Be sure the label is declare somewhere in the method with <i>LABEL</i></html>
GOTO_W|Go to label|<html> Description : Branch always<br> Syntax :<br> <table border=1><tr><td>GOTO_W &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go</li> </ul> Operand stack : <table border=1><tr><td>No change</td></tr></table><br> Details: Be sure the label is declare somewhere in the method with <i>LABEL</i><br> This instruction designed for big jump, but <i>GOTO</i> here auto transform in <i>GOTO_W</i> if jump is to big, so use <i>GOTO</i> and let compiler manage by it self</html>
I2B|int to bye|<html> Description : Convert int to byte<br> Syntax :<br> <table border=1><tr><td>I2B</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : value to convert (int)</li> <li>result : converted value (int)</li> </ul> Details: Truncated to a byte then sign-extended to an int result</html>
I2C|int to char|<html> Description :Convert int to char<br> Syntax :<br> <table border=1><tr><td>I2C</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : value to convert (int)</li> <li>result : converted value (int)</li> </ul> Details: Truncated to char, then zero-extended to an int result</html>
I2D|int to double|<html> Description : Convert int to double<br> Syntax :<br> <table border=1><tr><td>I2D</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : value to convert (int)</li> <li>result : converted value (double)</li> </ul></html>
I2F|int to float|<html> Description : Convert int to float<br> Syntax :<br> <table border=1><tr><td>I2F</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : value to convert (int)</li> <li>result : converted value (float)</li> </ul></html>
I2L|int to long|<html> Description : Convert int to long<br> Syntax :<br> <table border=1><tr><td>I2L</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : value to convert (int)</li> <li>result : converted value (long)</li> </ul></html>
I2S|int to short|<html> Description : Convert int to short<br> Syntax :<br> <table border=1><tr><td>I2S</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : value to convert (int)</li> <li>result : converted value (int)</li> </ul> Details: Truncated to a short, then sign-extended to an int result</html>
IADD|Addition of int|<html> Description : Add int<br> Syntax :<br> <table border=1><tr><td>IADD</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> <li>result : addition result (int)</li> </ul></html>
IALOAD|Load int from array|<html> Description : Load int from array<br> Syntax :<br> <table border=1><tr><td>IALOAD</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref, index => ..., value</td></tr></table><br> Where : <ul> <li>arrayref : Reference on array</li> <li>index : Array index (int)</li> <li>value : Value in array at given index (int)</li> </ul></html>
IAND|AND on int|<html> Description : And on int<br> Syntax :<br> <table border=1><tr><td>IAND</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> <li>result : and result (int)</li> </ul></html>
IASTORE|Store int to array|<html> Description : Store int to array<br> Syntax :<br> <table border=1><tr><td>IASTORE</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref, index, value => ...</td></tr></table><br> Where : <ul> <li>arrayref : Reference on array</li> <li>index : Array index (int)</li> <li>value : Value to put in array at given index (int)</li> </ul></html>
ICONST|Push -1 to 5|<html> Description : Push int constant -1, 0, 1 ,2, 3, 4 or 5<br> Syntax :<br> <table border=1><tr><td>ICONST &lt;value&gt;</td></tr></table><br> Where : <ul> <li>value : Value to push -1, 0, 1 ,2, 3, 4 or 5</li> </ul> <br> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>vlaue : value pushed -1, 0, 1 ,2, 3, 4 or 5 (int)</li> </ul></html>
IDIV|Division of int|<html> Description : Divide int<br> Syntax :<br> <table border=1><tr><td>IDIV</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> <li>result : division result (int)</li> </ul></html>
IF_ACMPEQ|IF == go label|<html> Description : Branch if reference comparison (equal) succeeds<br> Syntax :<br> <table border=1><tr><td>IF_ACMPEQ &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value1, value2 => ...</td></tr></table><br> Where : <ul> <li>value1 : reference to first object</li> <li>value2 : reference to second object</li> </ul></html>
IF_ACMPNE|If != go label|<html> Description : Branch if reference comparison (not equal) succeeds<br> Syntax :<br> <table border=1><tr><td>IF_ACMPNE &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value1, value2 => ...</td></tr></table><br> Where : <ul> <li>value1 : reference to first object</li> <li>value2 : reference to second object</li> </ul></html>
IF_ICMPEQ|IF == go label|<html> Description : Branch if int comparison (equal) succeeds<br> Syntax :<br> <table border=1><tr><td>IF_ICMPEQ &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value1, value2 => ...</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> </ul></html>
IF_ICMPGE|If >= go label|<html> Description : Branch if int comparison (greater or equal) succeeds<br> Syntax :<br> <table border=1><tr><td>IF_ICMPGE  &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value1, value2 => ...</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> </ul></html>
IF_ICMPGT|If > go label|<html> Description : Branch if int comparison (greater) succeeds<br> Syntax :<br> <table border=1><tr><td>IF_ICMPGT &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value1, value2 => ...</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> </ul></html>
IF_ICMPLE|If <= go label|<html> Description : Branch if int comparison (lower or equal) succeeds<br> Syntax :<br> <table border=1><tr><td>IF_ICMPLE &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value1, value2 => ...</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> </ul></html>
IF_ICMPLT|If < go label|<html> Description : Branch if int comparison (lower) succeeds<br> Syntax :<br> <table border=1><tr><td>IF_ICMPLT &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value1, value2 => ...</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> </ul></html>
IF_ICMPNE|If != go label|<html> Description : Branch if int comparison (not equal) succeeds<br> Syntax :<br> <table border=1><tr><td>IF_ICMPNE &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value1, value2 => ...</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> </ul></html>
IFEQ|If == 0 go label|<html> Description : Branch if int comparison (equal) with zero succeeds<br> Syntax :<br> <table border=1><tr><td>IFEQ &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value => ...</td></tr></table><br> Where : <ul> <li>value : int to compare at 0</li> </ul></html>
IFGE|If >= 0 go label|<html> Description : Branch if int comparison (greater or equal) with zero succeeds<br> Syntax :<br> <table border=1><tr><td>IFGE &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value => ...</td></tr></table><br> Where : <ul> <li>value : int to compare at 0</li> </ul></html>
IFGT|If > 0 go label|<html> Description : Branch if int comparison (greater) with zero succeeds<br> Syntax :<br> <table border=1><tr><td>IFGT &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value => ...</td></tr></table><br> Where : <ul> <li>value : int to compare at 0</li> </ul></html>
IFLE|If <= 0 go label|<html> Description : Branch if int comparison (lower or equal) with zero succeeds<br> Syntax :<br> <table border=1><tr><td>IFLE &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value => ...</td></tr></table><br> Where : <ul> <li>value : int to compare at 0</li> </ul></html>
IFLT|If < 0 go label|<html> Description : Branch if int comparison (lower) with zero succeeds<br> Syntax :<br> <table border=1><tr><td>IFLT &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value => ...</td></tr></table><br> Where : <ul> <li>value : int to compare at 0</li> </ul></html>
IFNE|If != 0 go label|<html> Description : Branch if int comparison (not equal) with zero succeeds<br> Syntax :<br> <table border=1><tr><td>IFNE &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value => ...</td></tr></table><br> Where : <ul> <li>value : int to compare at 0</li> </ul></html>
IFNONNULL|If != null go label|<html> Description : Branch if reference not null<br> Syntax :<br> <table border=1><tr><td>IFNONNULL &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value => ...</td></tr></table><br> Where : <ul> <li>value : reference object to compare with null</li> </ul></html>
IFNULL|If == null go label|<html> Description : Branch if reference is null<br> Syntax :<br> <table border=1><tr><td>IFNULL &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label name to go if condition respected</li> </ul> Operand stack : <table border=1><tr><td>..., value => ...</td></tr></table><br> Where : <ul> <li>value : reference object to compare with null</li> </ul></html>
IINC|Increment local variable|<html> Description : Increment local variable by constant<br> Syntax :<br> <table border=1><tr><td>IINC &lt;name&gt; &lt;value&gt;</td></tr></table><br> Where : <ul> <li>name : Current method variable name OR current method parameter name</li> <li>value : Value to increment with (int : signed byte)</li> </ul> Operand stack : <table border=1><tr><td>No change</td></tr></table><br></html>
ILOAD|Load local variable|<html> Description : Load int from local variable<br> Syntax :<br> <table border=1><tr><td>ILOAD &lt;name&gt;</td></tr></table><br> Where : <ul> <li>name : Current method variable name OR current method parameter name</li> </ul> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>value : method variable or parameter value (int)</li> </ul> Details: If method variable, MUST be previously initialized (Even with 0)</html>
IMPDEP1|???|<html> <img src="class:jhelp.gui.ResourcesGUI/warning.png" width="32" height="32"/>Description : Implementation dependent instruction (Not recommend to use it)<br> Syntax :<br> <table border=1><tr><td>IMPDEP1</td></tr></table><br></html>
IMPDEP2|???|<html> <img src="class:jhelp.gui.ResourcesGUI/warning.png" width="32" height="32"/>Description : Implementation dependent instruction (Not recommend to use it)<br> Syntax :<br> <table border=1><tr><td>IMPDEP2</td></tr></table><br></html>
IMUL|Multiplication of int|<html> Description : Multiply int<br> Syntax :<br> <table border=1><tr><td>IMUL</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> <li>result : multiplication result (int)</li> </ul></html>
INEG|Negate int|<html> Description : Negate int<br> Syntax :<br> <table border=1><tr><td>INEG</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : value to negate (int)</li> <li>result : negative result (int)</li> </ul></html>
INSTANCEOF|Check type|<html> Description : Determine if object is of given type<br> Syntax :<br> <table border=1><tr><td>INSTANCEOF &lt;ClassName&gt;</td></tr></table><br> Where : <ul> <li>ClassName : class name in complete version or short version (If short version must be in imports, java.lang or current class package)</li> </ul> Operand stack : <table border=1><tr><td>.., objectref => ..., result</td></tr></table><br> Where : <ul> <li>objectref : Reference on object to check the instance</li> <li>result : Comparison result (int)</li> </ul> Details: If objectref is null, the instanceof instruction pushes an int result of 0 as an int on the operand stack.<br> Otherwise, the named class, array, or interface type is resolved (§5.4.3.1). If objectref is an instance of the resolved class or array or implements the resolved interface, the instanceof instruction pushes an int result of 1 as an int on the operand stack; otherwise, it pushes an int result of 0</html>
INVOKEINTERFACE|Invoke interface method|<html> Description : Invoke interface method<br> Syntax :<br> <table border=1><tr><td>INVOKEINTERFACE &lt;methodCompleteDescription&gt; &lt;number&gt;</td></tr></table><br> Where : <ul> <li>methodCompleteDescription : Complete reference to a method : &lt;classCompleteName&gt;.&lt;methodName&gt;&lt;methodSignature&gt;</li> <li>number : number of arguments > 0</li> </ul> <br> Operand stack : <table border=1><tr><td>..., objectref, [arg1, [arg2 ...]] => ...</td></tr></table><br> Where : <ul> <li>objectref : Reference to object to call</li> <li>arg(i) : arguments send to method <li> </ul> Details:Let C be the class of objectref. The actual method to be invoked is selected by the following lookup procedure: <ul> <li>If C contains a declaration for an instance method with the same name and descriptor as the resolved method, then this is the method to be invoked, and the lookup procedure terminates.</li> <li>Otherwise, if C has a superclass, this same lookup procedure is performed recursively using the direct superclass of C; the method to be invoked is the result of the recursive invocation of this lookup procedure.</li> <li>Otherwise, an AbstractMethodError is raised.</li> </ul></html>
INVOKESPECIAL|Invoke super/private/init|<html> Description : Invoke instance method; special handling for superclass, private, and instance initialization method invocations<br> Syntax :<br> <table border=1><tr><td>INVOKESPECIAL &lt;methodCompleteDescription&gt;</td></tr></table><br> Where : <ul> <li>methodCompleteDescription : Complete reference to a method : &lt;classCompleteName&gt;.&lt;methodName&gt;&lt;methodSignature&gt;</li> </ul> Operand stack : <table border=1><tr><td>..., objectref, [arg1, [arg2 ...]] => ...</td></tr></table><br> Where : <ul> <li>objectref : Reference to object to call</li> <li>arg(i) : arguments send to method <li> </ul></html>
INVOKESTATIC|Invoke static method|<html> Description : Invoke a class (static) method<br> Syntax :<br> <table border=1><tr><td>INVOKESPECIAL &lt;methodCompleteDescription&gt;</td></tr></table><br> Where : <ul> <li>methodCompleteDescription : Complete reference to a method : &lt;classCompleteName&gt;.&lt;methodName&gt;&lt;methodSignature&gt;</li> </ul> Operand stack : <table border=1><tr><td>..., [arg1, [arg2 ...]] => ...</td></tr></table><br> Where : <ul> <li>arg(i) : arguments send to method <li> </ul></html>
INVOKEVIRTUAL|Invoke instance method|<html> Description : Invoke instance method; dispatch based on class<br> Syntax :<br> <table border=1><tr><td>INVOKEVIRTUAL &lt;methodCompleteDescription&gt;</td></tr></table><br> Where : <ul> <li>methodCompleteDescription : Complete reference to a method : &lt;classCompleteName&gt;.&lt;methodName&gt;&lt;methodSignature&gt;</li> </ul> Operand stack : <table border=1><tr><td>..., objectref, [arg1, [arg2 ...]] => ...</td></tr></table><br> Where : <ul> <li>objectref : Reference to object to call</li> <li>arg(i) : arguments send to method <li> </ul></html>
IOR|OR on int|<html> Description : Or on int<br> Syntax :<br> <table border=1><tr><td>IOR</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> <li>result : or result (int)</li> </ul></html>
IREM|Remainder of int|<html> Description : Remainder on int<br> Syntax :<br> <table border=1><tr><td>IREM</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> <li>result : remainder result (int)</li> </ul></html>
IRETURN|Return int|<html> Description : Return int from method<br> Syntax :<br> <table border=1><tr><td>IRETURN</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => [empty]</td></tr></table><br> Where : <ul> <li>value : Value to return (int)</li> </ul></html>
ISHL|<< on int|<html> Description : Shift left int (&lt;&lt;)<br> Syntax :<br> <table border=1><tr><td>ISHL</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> <li>result : shift left result (int)</li> </ul></html>
ISHR|>> on int|<html> Description : Shift right int (&gt;&gt;)<br> Syntax :<br> <table border=1><tr><td>ISHR</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> <li>result : shift right result (int)</li> </ul></html>
ISTORE|Store on local variable|<html> Description : Store int to local variable<br> Syntax :<br> <table border=1><tr><td>ISTORE &lt;name&gt;</td></tr></table><br> Where : <ul> <li>name : Current method variable name OR current method parameter name</li> </ul> Operand stack : <table border=1><tr><td>..., value => ... </td></tr></table><br> Where : <ul> <li>value : value to put in method variable or parameter (int)</li> </ul></html>
ISUB|Subtraction of int|<html> Description : Subtract int<br> Syntax :<br> <table border=1><tr><td>ISUB</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> <li>result : subtraction result (int)</li> </ul></html>
IUSHR|>>> on int|<html> Description : Logical shift right int (&gt;&gt;&gt;)<br> Syntax :<br> <table border=1><tr><td>ISHR</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> <li>result : shift right result (int)</li></html>
IXOR|XOR on int|<html> Description : XOR on int<br> Syntax :<br> <table border=1><tr><td>IXOR</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first int</li> <li>value2 : second int</li> <li>result : XOR result (int)</li> </ul></html>
JSR|Jump subroutine|<html> Description : Jump subroutine<br> Syntax :<br> <table border=1><tr><td>JSR &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label to jump</li> </ul> Operand stack : <table border=1><tr><td>... => ..., address</td></tr></table><br> Where : <ul> <li>address : Address to return</li> </ul> Details: In sub routine remember to store return address in local variable to use with <i>RET</i></html>
JSR_W|Jump subroutine|<html> Description : Jump subroutine<br> Syntax :<br> <table border=1><tr><td>JSR_W &lt;label&gt;</td></tr></table><br> Where : <ul> <li>label : Label to jump</li> </ul> Operand stack : <table border=1><tr><td>... => ..., address</td></tr></table><br> Where : <ul> <li>address : Address to return</li> </ul> Details: In sub routine remember to store return address in local variable to use with <i>RET</i><br> <i>JSR_W</i> are for long jump, use <i>JSR</i> and compiler will choose the best one for you</html>
L2D|long to double|<html> Description : Convert long to double<br> Syntax :<br> <table border=1><tr><td>L2D</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : value to convert (long)</li> <li>result : converted value (double)</li> </ul> Details: Converted to a double result using IEEE 754 round to nearest mode</html>
L2F|long to float|<html> Description : Convert long to float<br> Syntax :<br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : value to convert (long)</li> <li>result : converted value (float)</li> </ul> Details: Converted to a float result using IEEE 754 round to nearest mode.</html>
L2I|long to int|<html> Description : Convert long to int<br> Syntax :<br> <table border=1><tr><td>L2I</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : value to convert (long)</li> <li>result : converted value (int)</li> </ul> Details: Converted to an int result by taking the low-order 32 bits of the long value and discarding the high-order 32 bits.</html>
LADD|Addition on long|<html> Description : Add long<br> Syntax :<br> <table border=1><tr><td>LADD</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first long</li> <li>value2 : second long</li> <li>result : addition result (long)</li> </ul></html>
LALOAD|Load long from array|<html> Description : Load long from array<br> Syntax :<br> <table border=1><tr><td>LALOAD</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref, index => ..., value</td></tr></table><br> Where : <ul> <li>arrayref : Reference on array</li> <li>index : Array index (int)</li> <li>value : Value in array at given index (long)</li> </ul></html>
LAND|AND on long|<html> Description : And on long<br> Syntax :<br> <table border=1><tr><td>LAND</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first long</li> <li>value2 : second long</li> <li>result : and result (long)</li> </ul></html>
LASTORE|Store long to array|<html> Description : Load long from array<br> Syntax :<br> <table border=1><tr><td>LASTORE</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref, index, value => ...</td></tr></table><br> Where : <ul> <li>arrayref : Reference on array</li> <li>index : Array index (int)</li> <li>value : Value to put in array at given index (long)</li> </ul></html>
LCMP|Compare long|<html> Description : Compare long<br> Syntax :<br> <table border=1><tr><td>LCMP</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ...,result</td></tr></table><br> Where : <ul> <li>value1 : first long</li> <li>value2 : second long</li> <li>result : comparison result (int)</li> </ul> <br> Details:If value1 is greater than value2, the int value 1 is pushed onto the operand stack. If value1 is equal to value2, the int value 0 is pushed onto the operand stack. If value1 is less than value2, the int value -1 is pushed onto the operand stack.</html>
LCONST|Push 0 or 1|<html> Description : Push long constant 0 or 1<br> Syntax :<br> <table border=1><tr><td>LCONST &lt;value&gt;</td></tr></table><br> Where : <ul> <li>value : value to push 0 or 1</li> </ul> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>value pushed value 0 or 1 (long)</li> </ul></html>
LDC|Push from constant pool|<html> Description : Push item from run-time constant pool. Laod a constant<br> Syntax :<br> <table border=1><tr><td>LDC &lt;value&gt;</td></tr></table><br> Where : <ul> <li>value : constant value</li> </ul> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>value reference to value (If String) or value itself</li> </ul> Details: Value of constant can be : <ul> <li>boolean : true or false</li> <li>character : 'a', 'z', '\n', ... (Must be inside ' like Java convention for character)</li> <li>int : 123, 89, 20, -9, ...</li> <li>float : 1.23f, 5f, -.36f, ... Must end with f</li> <li>String : "This is a phrase.", "", "Blabla\n\t\"New line\"", ... Like Java String convention</li> </ul> Since byte and short are carry by int, use int for them<br> For long and double use <i>LDC2_W</i></html>
LDC_W|Push from constant pool|<html> Description : Push item from run-time constant pool. Laod a constant<br> Syntax :<br> <table border=1><tr><td>LDC_W &lt;value&gt;</td></tr></table><br> Where : <ul> <li>value : constant value</li> </ul> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>value reference to value (If String) or value itself</li> </ul> Details: Value of constant can be : <ul> <li>boolean : true or false</li> <li>character : 'a', 'z', '\n', ... (Must be inside ' like Java convention for character)</li> <li>int : 123, 89, 20, -9, ...</li> <li>float : 1.23f, 5f, -.36f, ... Must end with f</li> <li>String : "This is a phrase.", "", "Blabla\n\t\"New line\"", ... Like Java String convention</li> </ul> Since byte and short are carry by int, use int for them<br> For long and double use <i>LDC2_W</i></html>
LDC2_W|Push from constant pool|<html> Description : Push item from run-time constant pool. Laod a constant<br> Syntax :<br> <table border=1><tr><td>LDC2_W &lt;value&gt;</td></tr></table><br> Where : <ul> <li>value : constant value</li> </ul> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>value reference to value (If String) or value itself</li> </ul> Details: Value of constant can be : <ul> <li>long : 3l, 40L, -8l, ... end with l like Java</li> <li>double : 12.3, 0.3, 8d, 3.2D, d at end is mandatory if can be confused with int (No decimal separator)</li> </ul> For other constants use <i>LDC</i> or <i>LDC_W</i></html>
LDIV|Division of long|<html> Description : Divide long<br> Syntax :<br> <table border=1><tr><td>LDIV</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first long</li> <li>value2 : second long</li> <li>result : division result (long)</li> </ul></html>
LLOAD|Load from local variable|<html> Description : Load long from local variable<br> Syntax :<br> <table border=1><tr><td>LLOAD &lt;name&gt;</td></tr></table><br> Where : <ul> <li>name : Current method variable name OR current method parameter name</li> </ul> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>value : method variable or parameter value (long)</li> </ul> Details: If method variable, MUST be previously initialized (Even with 0)</html>
LMUL|Multiplication of long|<html> Description : Multiply long<br> Syntax :<br> <table border=1><tr><td>LMUL</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first long</li> <li>value2 : second long</li> <li>result : multiplication result (long)</li> </ul></html>
LNEG|Negate long|<html> Description : Negate long<br> Syntax :<br> <table border=1><tr><td>LNEG</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => ..., result</td></tr></table><br> Where : <ul> <li>value : Value to negate (long)</li> <li>result : Negative result (long)</li> </ul> <br> Details:</html>
LOOKUPSWITCH|Switch to labels|<html> Description : Switch to label depends on given key<br> Syntax :<br> <table border=1><tr><td>LOOKUPSWITCH (&lt;match&gt; &lt;label&gt;)* &lt;defaultLabel&gt;  </td></tr></table><br> Where : <ul> <li>match : Match value (int)</li> <li>label : Label to go if key match to match value</li> <li>defaultLabel : Label to go if key not match</li> </ul> <br> Operand stack : <table border=1><tr><td>..., key => ...</td></tr></table><br> Where : <ul> <li>key : the key value (int)</li> </ul> <br> Details: <i>LOOKUPSWITCH</i> is designed for switch can't respect <i>TABLESWITCH</i> constraints.<br> If you don't know the best choose between <i>LOOKUPSWITCH</i> and <i>TABLESWITCH</i> use the <i>SWITCH</i> instruction it will choose the best optimized instruction to use</html>
LOR|OR on long|<html> Description : Or on long<br> Syntax :<br> <table border=1><tr><td>LOR</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first long</li> <li>value2 : second long</li> <li>result : or result (long)</li> </ul></html>
LREM|Remainder on long|<html> Description : Remainder long<br> Syntax :<br> <table border=1><tr><td>LREM</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first long</li> <li>value2 : second long</li> <li>result : remainder result (long)</li> </ul></html>
LRETURN|Return long|<html> Description : Return long from method<br> Syntax :<br> <table border=1><tr><td>LRETURN</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value => [empty]</td></tr></table><br> Where : <ul> <li>value : Value to return (long)</li> </ul></html>
LSHL|<< on long|<html> Description : Shift left long (&lt;&lt;)<br> Syntax :<br> <table border=1><tr><td>LSHL</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first long</li> <li>value2 : second int</li> <li>result : shift left result (long)</li> </ul></html>
LSHR|>> on long|<html> Description : Shift right long (&gt;&gt;)<br> Syntax :<br> <table border=1><tr><td>LSHR</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first long</li> <li>value2 : second int</li> <li>result : shift right result (long)</li> </ul></html>
LSTORE|Store to local variable|<html> Description : Store long to local variable<br> Syntax :<br> <table border=1><tr><td>LLOAD &lt;name&gt;</td></tr></table><br> Where : <ul> <li>name : Current method variable name OR current method parameter name</li> </ul> Operand stack : <table border=1><tr><td>..., value => ...</td></tr></table><br> Where : <ul> <li>value : value to put in method variable or parameter (long)</li> </ul></html>
LSUB|Subtraction on long|<html> Description : Subtract long <br> Syntax :<br> <table border=1><tr><td>LSUB</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first long</li> <li>value2 : second long</li> <li>result : subtraction result (long)</li> </ul></html>
LUSHR|>>> on long|<html> Description : Logical Shift right long (&lt;&lt;&lt;)<br> Syntax :<br> <table border=1><tr><td>LSHR</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first long</li> <li>value2 : second int</li> <li>result : shift right result (long)</li> </ul></html>
LXOR|XOR on long|<html> Description : XOR long<br> Syntax :<br> <table border=1><tr><td>LSHR</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., result</td></tr></table><br> Where : <ul> <li>value1 : first long</li> <li>value2 : second long</li> <li>result : XOR result (long)</li> </ul></html>
MONITORENTER|Enter monitor|<html> Description : Enter monitor for object<br> Syntax :<br> <table border=1><tr><td>MONITORENTER</td></tr></table><br> Operand stack : <table border=1><tr><td>..., objectref => ...</td></tr></table><br> Where : <ul> <li>objectref : reference of object to enter in monitor</li> </ul> Details: Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows: <ul> <li>If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</li> <li>If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</li> <li>If another thread already owns the monitor associated with objectref, the thread blocks until the monitor's entry count is zero, then tries again to gain ownership.</li> </ul></html>
MONITOREXIT|Exit monitor|<html> Description : Exit monitor for object<br> Syntax :<br> <table border=1><tr><td>MONITOREXIT</td></tr></table><br> Operand stack : <table border=1><tr><td>..., objectref => ...</td></tr></table><br> Where : <ul> <li>objectref: reference to object to exit monitor</li> </ul> Details: The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref. <br> The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</html>
MULTIANEWARRAY|New multidimensional array|<html> Description : Create new multidimensional array<br> Syntax :<br> <table border=1><tr><td>MULTIANEWARRAY &lt;type&gt; &lt;numberOfDimensions&gt;</td></tr></table><br> Where : <ul> <li>type : Array type (signature or class name)</li> <li>numberOfDimensions : Number of dimensions (int)</li> </ul> Operand stack : <table border=1><tr><td>.., count1, [count2, ...] => ..., arrayref</td></tr></table><br> Where : <ul> <li>count(i) : size for dimension i</li> <li>arrayref : reference on created array</li> </ul></html>
NEW|New object|<html> Description : Create new object<br> Syntax :<br> <table border=1><tr><td>NEW &lt;type&gt;</td></tr></table><br> Where : <ul> <li>type : array type class name or signature</li> </ul> Operand stack : <table border=1><tr><td>... => ..., objectref</td></tr></table><br> Where : <ul> <li>objectref : reference on created object</li> </ul></html>
NEWARRAY|New array|<html> Description : Create new array<br> Syntax :<br> <table border=1><tr><td>NEWARRAY &lt;primitiveType&gt;</td></tr></table><br> Where : <ul> <li>primitiveType : primitive array type : boolean, char, byte, short, int, long, float, double</li> </ul> Operand stack : <table border=1><tr><td>..., count => ..., arrayref</td></tr></table><br> Where : <ul> <li>count : Array size (int)</li> <li>arrayref : Reference on array</li> </ul></html>
NOP|No operation|<html> Description : Do nothing<br> Syntax :<br> <table border=1><tr><td>NOP</td></tr></table><br> Operand stack : <table border=1><tr><td>No change</td></tr></table></html>
POP|Pop value|<html> Description : Pop the top operand stack value</td></tr></table><br> Syntax :<br> <table border=1><tr><td>POP</td></tr></table><br> Operand stack : <table border=1><tr><td>.., value => ...</td></tr></table><br> Where : <ul> <li>value : value to pop (Not long nor double)</li> </ul></html>
POP2|Pop value|<html> Description : Pop the top one or two operand stack values<br> Syntax :<br> <table border=1><tr><td>POP2</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value2, value1 => ...</td></tr></table><br> Where : <ul> <li>value1 : value to pop (Not long nor double)</li> <li>value2 : value to pop (Not long nor double)</li> </ul> <br> <h1><b>OR</b></h1><br> <br> Operand stack : <table border=1><tr><td>..., value => ...</td></tr></table><br> Where : <ul> <li>value : value to pop (long or double)</li> </ul></html>
PUSH|Push value|<html> Description : Convenient instruction for push a value (It choose the good instruction for push the value)<br> Syntax :<br> <table border=1><tr><td>PUSH  &lt;constantValue&gt;</td></tr></table><br> Where : <ul> <li>constantValue : constant value to push</li> </ul> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>value : Value pushed</li> </ul> Details: The constant can have several form : <ul> <li>boolean : true or false (int pushed)</li> <li>char : 'a', 'z', '\t', ... like Java character (int pushed)</li> <li>int : 12, -5, 3, ... (int pushed)</li> <li>long : 15l, -8L, ... L end to indicates it is long (long pushed)</li> <li>float : 1f, 0.2f, .3F, ... F end to indicates it is float (float pushed)</li> <li>double : 1.0, 5d, 3.2D, ... with ., or end with D (double pushed)</li> <li>String : "file", "", "phrase\nhi" Like Java String (reference to String pushed)</li> </ul></html>
PUTFIELD|Put value on field|<html> Description : Set field in object<br> Syntax :<br> <table border=1><tr><td>PUTFIELD &lt;fieldName&gt;</td></tr></table><br> Where : <ul> <li>fieldName : Name/alias of the field</li> </ul> Operand stack : <table border=1><tr><td>..., objectref, value => ...</td></tr></table><br> Where : <ul> <li>objectref : Reference on object</li> <li>value : Value to push on field</li> </ul></html>
PUTSTATIC|Put value on field|<html> Description : Set static field in object<br> Syntax :<br> <table border=1><tr><td>PUTFIELD &lt;fieldName&gt;</td></tr></table><br> Where : <ul> <li>fieldName : Name/alias of the field</li> </ul> Operand stack : <table border=1><tr><td>..., value => ...</td></tr></table><br> Where : <ul> <li>value : Value to push on field</li> </ul></html>
RET|Return from subroutine|<html> Description : Return from subroutine<br> Syntax :<br> <table border=1><tr><td>RET &lt;localVaraible&gt;</td></tr></table><br> Where : <ul> <li>localVaraible : Name of local variable where return address is stored</li> </ul> Operand stack : <table border=1><tr><td>No change </td></tr></table><br> Details: It is used in combination with <i>JSR</i>/<i>JSR_W</i>.<br> When enter in subroutine, the return address is on the top of the stack, if you want things go properly, you can adopt 2 strategies : <ol> <li>The most easy is to store the return address in local variable as first instruction of subroutine and not modify this variable until the end of the subroutine to use it only for <i>RET</i>.</li> <li>Or pay attention to stack status in way that the address not delete from the stack and be at top at the end of subroutine and store it in local variable just before call the <i>RET</i>.</li> </ol></html>
RETURN|Return void|<html> Description : Return void from method<br> Syntax :<br> <table border=1><tr><td>RETURN</td></tr></table><br> Operand stack : <table border=1><tr><td>... => [empty]</td></tr></table><br></html>
SALOAD|Load from local variable|<html> Description : Load short from array<br> Syntax :<br> <table border=1><tr><td>SALOAD</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref, index => ..., value</td></tr></table><br> Where : <ul> <li>arrayref : Array reference</li> <li>index : Array index (int)</li> <li>value : Value in array at index (int)</li> </ul> Details: The short value is sign-extended to an int value</html>
SASTORE|Store to local variable|<html> Description : Store short to array<br> Syntax :<br> <table border=1><tr><td>SASTORE</td></tr></table><br> Operand stack : <table border=1><tr><td>..., arrayref, index, value => ...</td></tr></table><br> Where : <ul> <li>arrayref : Array reference</li> <li>index : Array index (int)</li> <li>value : Value to put in array at index (int)</li> </ul> Details: The int value is truncated to short value</html>
SIPUSH|Push short|<html> Description : Push short<br> Syntax :<br> <table border=1><tr><td>SIPUSH &lt;value&gt;</td></tr></table><br> Where : <ul> <li>value : Value to push (short)</li> </ul> Operand stack : <table border=1><tr><td>... => ..., value</td></tr></table><br> Where : <ul> <li>value ; Value pushed (int)</li> </ul> Details: The short value is sign-extended to an int value</html>
SWAP|Exchange value|<html> Description : Swap the top two operand stack values<br> Syntax :<br> <table border=1><tr><td>SWAP</td></tr></table><br> Operand stack : <table border=1><tr><td>..., value1, value2 => ..., value2, value1</td></tr></table><br> Where : <ul> <li>value1 : Value to swap (Not double nor long)</li> <li>value2 : Value to swap (Not double nor long)</li> </ul></html>
SWITCH|Switch to labels|<html> Description : Switch to label depends on given key<br> Syntax :<br> <table border=1><tr><td>SWITCH (&lt;match&gt; &lt;label&gt;)* &lt;defaultLabel&gt;  </td></tr></table><br> Where : <ul> <li>match : Match value (int)</li> <li>label : Label to go if key match to match value</li> <li>defaultLabel : Label to go if key not match</li> </ul> <br> Operand stack : <table border=1><tr><td>..., key => ...</td></tr></table><br> Where : <ul> <li>key : the key value (int)</li> </ul> <br> Details: <i>SWITCH</i> instruction will choose the best optimized instruction choose between <i>LOOKUPSWITCH</i> and <i>TABLESWITCH</i> depends on given match/label pairs</html>
TABLESWITCH|Switch to labels|<html> Description : Switch to label depends on given key<br> Syntax :<br> <table border=1><tr><td>TABLESWITCH (&lt;match&gt; &lt;label&gt;)* &lt;defaultLabel&gt;  </td></tr></table><br> Where : <ul> <li>match : Match value (int)</li> <li>label : Label to go if key match to match value</li> <li>defaultLabel : Label to go if key not match</li> </ul> <br> Operand stack : <table border=1><tr><td>..., key => ...</td></tr></table><br> Where : <ul> <li>key : the key value (int)</li> </ul> <br> Details: <i>TABLESWITCH</i> is designed for switch with a limited number of case and gap between case not too big<br> If you don't know the best choose between <i>LOOKUPSWITCH</i> and <i>TABLESWITCH</i> use the <i>SWITCH</i> instruction it will choose the best optimized instruction to use</html>

*******************************
*** Additional instructions ***
*******************************

LABEL|Declare label|<html> Special instruction (Not opcode) for declare a label<br> Syntax :<br> <table border=1><tr><td>LABEL &lt;name&gt;</td></tr></table><br> Where <i>name</i> is the label name and respects [a-zA-Z][a-zA-Z0-9_]*</html>
SUB_C|Subroutine call|<html> Special instruction for call a subroutine<br> Syntax :<br> <table border=1><tr><td>SUB_C &lt;name&gt;</td></tr></table><br> Where <table border=1><tr><td>name</td></tr></table> is the subroutine name to call. <br> Operand stack : <table border=1><tr><td>... => ..., address</td></tr></table><br> Where address is the address to return<br> Details : Instructions <i>SUB_C</i>, <i>SUB_S</i> and <i>SUB_E</i> are to facilitate the subroutine creation to resolve the problem of return address<br> Here it call the subroutine, just use its name.<br> Warning subroutines must be have one <i>SUB_S</i> and one <i>SUB_E</i> (The sub routine code is between this 2 instructions). Then they MUST be call with <i>SUB_C</i> (You can use it in several places), other branch instruction outside subroutine code that goes inside subroutine code may cause unexpected result or crash. Same risk apply if exit from subroutine code without <i>SUB_E</i> or call an other subroutine with <i>SUB_C</i>. The subroutine don't manage well the recursive call here, if you want some, you have to deal with <i>JSR</i>/<i>JSR_W</i> and <i>RET</i> and apply the second strategy explains in <i>RET</i>.</html>
SUB_E|Subroutine end|<html> Special instruction for end a subroutine code<br> Syntax :<br> <table border=1><tr><td>SUB_E &lt;name&gt;</td></tr></table><br> Where <table border=1><tr><td>name</td></tr></table> is the subroutine name to exit. <br> Operand stack : <table border=1><tr><td>No change</td></tr></table> <br> Details : Instructions <i>SUB_C</i>, <i>SUB_S</i> and <i>SUB_E</i> are to facilitate the subroutine creation to resolve the problem of return address<br> Use this instruction to terminate the subroutine code <br> Warning subroutines must be have one <i>SUB_S</i> and one <i>SUB_E</i> (The sub routine code is between this 2 instructions). Then they MUST be call with <i>SUB_C</i> (You can use it in several places), other branch instruction outside subroutine code that goes inside subroutine code may cause unexpected result or crash. Same risk apply if exit from subroutine code without <i>SUB_E</i> or call an other subroutine with <i>SUB_C</i>. The subroutine don't manage well the recursive call here, if you want some, you have to deal with <i>JSR</i>/<i>JSR_W</i> and <i>RET</i> and apply the second strategy explains in <i>RET</i>.</html>
SUB_S|Subroutine start|<html> Special instruction for start a subroutine code<br> Syntax :<br> <table border=1><tr><td>SUB_S &lt;name&gt;</td></tr></table><br> Where <table border=1><tr><td>name</td></tr></table> is the subroutine name to start. <br> Operand stack : <table border=1><tr><td>..., address -> ...</td></tr></table> <br> Details : Instructions <i>SUB_C</i>, <i>SUB_S</i> and <i>SUB_E</i> are to facilitate the subroutine creation to resolve the problem of return address<br> Use this instruction to start the subroutine code<br> Warning subroutines must be have one <i>SUB_S</i> and one <i>SUB_E</i> (The sub routine code is between this 2 instructions). Then they MUST be call with <i>SUB_C</i> (You can use it in several places), other branch instruction outside subroutine code that goes inside subroutine code may cause unexpected result or crash. Same risk apply if exit from subroutine code without <i>SUB_E</i> or call an other subroutine with <i>SUB_C</i>. The subroutine don't manage well the recursive call here, if you want some, you have to deal with <i>JSR</i>/<i>JSR_W</i> and <i>RET</i> and apply the second strategy explains in <i>RET</i>.</html>
VAR|Declare local variable|<html> Special instruction (Not opcode) for declare a variable<br> Syntax:<br> <table border=1><tr><td>VAR &lt;Type&gt; &lt;name&gt;</td></tr></table><br> Where <table border=1><tr><td>Type</td></tr></table> is the variable type. <br> Where <table border=1><tr><td>name</td></tr></table> is the variable name and respects [a-zA-Z][a-zA-Z0-9_]*</html>
TRY|Start try/catch block|<html> Special instruction (Not opcode) for start try/catch block<br> Syntax:<br> <table border=1><tr><td>TRY &lt;Type&gt; &lt;name&gt;</td></tr></table><br> Where <table border=1><tr><td>Type</td></tr></table> is the exception type. <br> Where <table border=1><tr><td>name</td></tr></table> is the exception name and respects [a-zA-Z][a-zA-Z0-9_]*</html>
CATCH|End try/catch block|<html> Special instruction (Not opcode) for end try/catch block<br> Syntax:<br> <table border=1><tr><td>CATCH &lt;name&gt; &lt;label&gt;</td></tr></table><br> Where <table border=1><tr><td>name</td></tr></table> is the exception name and respects [a-zA-Z][a-zA-Z0-9_]*<br> Where <table border=1><tr><td>label</td></tr></table> is the label to go if exception happen</html> 
